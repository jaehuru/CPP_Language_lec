#include <iostream>

using namespace std;

// 포인터

// [매개변수][RET][지역변수(hp = 1)] [매개변수(주소)][RET][지역변수]
void SetHp(int* hp)
{
	*hp = 100; // hp의 주소로 넘어가서 그 알멩이를 건드는것이기 때문에 main에 hp값을 직접 건들여버림..
}


int main()
{
	int hp = 1;
	// SetHp(hp); 값이 변하지 않음.
	SetHp(&hp);  

	cout << hp << endl;

	// 지금까지 사용한 방식
	// [타입] [변수이름] 의 바구니를 만든다
	// 변수 스택 메모리에 할당
	// 따라서 스택 메모리에 있는 특정 주소에 우리가 원하는 값을 넣은 셈
	int a = 1;

	// [TYPE*] [변수이름];
	// 바구니는 바구니인데
	// [주소를 저장하는 바구니]
	// 변수 선언할 때 * 등장 -> 포인터 = 주소
	// 참고) 포인터라는 바구니는 4바이트 or 8바이트 고정크기
	int* ptr = &a;

	// 근데 남의 주소를 갖고 뭐해?
	// 추가 문법 : [주소를 저장하는 바구니]가 가르키는 주소로 가서 무엇인가를 해라!
	// *변수이름 = 값;

	// 포탈을 타고 순간이동 한다고 생각해보자
	// - 변수 선언(주소를 저장하는 바구니다!)
	// - 사용할 떄(포탈 타고 순간이동)

	int value1 = *ptr;
	*ptr = 2;

	// TYPE은 왜 붙여줄까?
	// * = 포인터의 의미 = 주소를 저장하는 바구니 = 4/8바이트 고정 크기
	// 추가정보를 주는 느낌 -> 주소에 가면 뭐가 있는지 int인지 float인지 그런
	
	// 타입의 불일치
	//__int64* ptr2 = &number;

	return 0;
}